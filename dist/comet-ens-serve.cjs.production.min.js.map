{"version":3,"file":"comet-ens-serve.cjs.production.min.js","sources":["../src/utils.ts","../lib/db.ts","../lib/utils/query.ts","../src/json.ts","../src/server.ts","../src/index.ts"],"sourcesContent":["export const ETH_COIN_TYPE = 60;\n","import { PrismaClient } from \"@prisma/client\";\nimport { withAccelerate } from \"@prisma/extension-accelerate\";\n\n// Learn more about instantiating PrismaClient in Next.js here: https://www.prisma.io/docs/data-platform/accelerate/getting-started\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient().$extends(withAccelerate());\n};\n\ndeclare const globalThis: {\n    prismaGlobal: ReturnType<typeof prismaClientSingleton>;\n} & typeof global;\n\nconst prisma = globalThis.prismaGlobal ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prismaGlobal = prisma;","import prisma from \"../db\";\n\nexport const getAddress = async (node: string) => {\n    return await prisma.ens.findUnique({\n        // @ts-ignore\n        where: {\n            node: node,\n        },\n        select: {\n            address: true,\n        }\n    });\n}\n\nexport const getText = async (node: string) => {\n    return await prisma.ens.findUnique({\n        // @ts-ignore\n        where: {\n            node: node,\n        },\n        select: {\n            text: true,\n        }\n    });\n}\n\nexport const getContenthash = async (node: string) => {\n    return await prisma.ens.findUnique({\n        // @ts-ignore\n        where: {\n            node: node,\n        },\n        select: {\n            contenthash: true,\n        }\n    });\n}","import { getAddress, getText, getContenthash } from '../lib/utils/query';\n\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst EMPTY_CONTENT_HASH = '0x';\nconst ttl = 300;\n\nexport async function addr(name: string, coinType: number) {\n  try {\n    let addresses = await getAddress(name);\n    // @ts-ignore\n    addresses = addresses?.address;\n    let addr = ZERO_ADDRESS;\n    // @ts-ignore\n    if (addresses && addresses[coinType]) {\n      // @ts-ignore\n      addr = '' + addresses[coinType];\n    }\n    return { addr, ttl };\n\n  } catch (e) {\n    return { addr: ZERO_ADDRESS, ttl };\n  }\n}\n\nexport async function text(name: string, key: string) {\n  try {\n    const texts = await getText(name);\n    // @ts-ignore\n    const text = texts?.text;\n\n    // @ts-ignore\n    if (text && text[key]) {   // @ts-ignore\n      return { value: text[key], ttl };\n    } else {\n      return { value: '', ttl };\n    }\n  } catch (e) {\n    return { value: '', ttl };\n  }\n}\n\nexport async function contenthash(name: string) {\n  try {\n    const contenthashRes = await getContenthash(name);\n    // @ts-ignore\n    const contenthash = contenthashRes?.contenthash;\n\n    if (contenthash) {\n      return { contenthash: contenthash, ttl };\n    } else {\n      return { contenthash: EMPTY_CONTENT_HASH, ttl };\n    }\n  } catch (e) {\n    return { contenthash: EMPTY_CONTENT_HASH, ttl };\n  }\n}\n","import { Server } from '@chainlink/ccip-read-server';\nimport { ethers, BytesLike } from 'ethers';\nimport { hexConcat, Result } from 'ethers/lib/utils';\nimport { ETH_COIN_TYPE } from './utils';\nimport { addr as getAddr, text, contenthash as getContentHash } from './json'\nimport { abi as IResolverService_abi } from '@ensdomains/offchain-resolver-contracts/artifacts/contracts/OffchainResolver.sol/IResolverService.json';\nimport { abi as Resolver_abi } from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\nconst Resolver = new ethers.utils.Interface(Resolver_abi);\n\ninterface DatabaseResult {\n  result: any[];\n  ttl: number;\n}\n\ntype PromiseOrResult<T> = T | Promise<T>;\n\nexport interface Database {\n  addr(\n    name: string,\n    coinType: number\n  ): PromiseOrResult<{ addr: string; ttl: number }>;\n  text(\n    name: string,\n    key: string\n  ): PromiseOrResult<{ value: string; ttl: number }>;\n  contenthash(\n    name: string\n  ): PromiseOrResult<{ contenthash: string; ttl: number }>;\n}\n\nfunction decodeDnsName(dnsname: Buffer) {\n  const labels = [];\n  let idx = 0;\n  while (true) {\n    const len = dnsname.readUInt8(idx);\n    if (len === 0) break;\n    labels.push(dnsname.slice(idx + 1, idx + len + 1).toString('utf8'));\n    idx += len + 1;\n  }\n  return labels.join('.');\n}\n\nconst queryHandlers: {\n  [key: string]: (\n    name: string,\n    args: Result\n  ) => Promise<DatabaseResult>;\n} = {\n  'addr(bytes32)': async (name, _args) => {\n    const { addr, ttl } = await getAddr(name, ETH_COIN_TYPE);\n    return { result: [addr], ttl };\n  },\n  'addr(bytes32,uint256)': async (name, args) => {\n    const { addr, ttl } = await getAddr(name, args[0]);\n    return { result: [addr], ttl };\n  },\n  'text(bytes32,string)': async (name, args) => {\n    const { value, ttl } = await text(name, args[0]);\n\n    return { result: [value], ttl };\n  },\n  'contenthash(bytes32)': async (name, _args) => {\n    const { contenthash, ttl } = await getContentHash(name);\n\n    return { result: [contenthash], ttl };\n  },\n};\n\nasync function query(\n  name: string,\n  data: string\n): Promise<{ result: BytesLike; validUntil: number }> {\n  // Parse the data nested inside the second argument to `resolve`\n  const { signature, args } = Resolver.parseTransaction({ data });\n\n  if (ethers.utils.nameprep(name) !== name) {\n    throw new Error('Name must be normalised');\n  }\n\n  if (ethers.utils.namehash(name) !== args[0]) {\n    throw new Error('Name does not match namehash');\n  }\n\n  const handler = queryHandlers[signature];\n  if (handler === undefined) {\n    throw new Error(`Unsupported query function ${signature}`);\n  }\n\n  const { result, ttl } = await handler(name, args.slice(1));\n\n  return {\n    result: Resolver.encodeFunctionResult(signature, result),\n    validUntil: Math.floor(Date.now() / 1000 + ttl),\n  };\n}\n\nexport function makeServer(signer: ethers.utils.SigningKey) {\n  const server = new Server();\n  server.add(IResolverService_abi, [\n    {\n      type: 'resolve',\n      func: async ([encodedName, data]: Result, request) => {\n        const name = decodeDnsName(Buffer.from(encodedName.slice(2), 'hex'));\n        // Query the database\n        const { result, validUntil } = await query(name, data);\n\n        // Hash and sign the response\n        let messageHash = ethers.utils.solidityKeccak256(\n          ['bytes', 'address', 'uint64', 'bytes32', 'bytes32'],\n          [\n            '0x1900',\n            request?.to,\n            validUntil,\n            ethers.utils.keccak256(request?.data || '0x'),\n            ethers.utils.keccak256(result),\n          ]\n        );\n        const sig = signer.signDigest(messageHash);\n        const sigData = hexConcat([sig.r, sig._vs]);\n\n        return [result, validUntil, sigData];\n      },\n    },\n  ]);\n  return server;\n}\n\nexport function makeApp(\n  signer: ethers.utils.SigningKey,\n  path: string,\n) {\n  return makeServer(signer).makeApp(path);\n}\n","import { makeApp } from './server';\n// import { Command } from 'commander';\n// import { readFileSync } from 'fs';\nimport { ethers } from 'ethers';\n// const program = new Command();\n// program\n//   .requiredOption(\n//     '-k --private-key <key>',\n//     'Private key to sign responses with. Prefix with @ to read from a file'\n//   )\n//   // .requiredOption('-d --data <file>', 'JSON file to read data from')\n//   // .option('-t --ttl <number>', 'TTL for signatures', '300')\n//   .option('-p --port <number>', 'Port number to serve on', '8080');\n// program.parse(process.argv);\n// const options = program.opts();\nlet privateKey = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\nconst port = 10000\n// if (privateKey.startsWith('@')) {\n//   privateKey = ethers.utils.arrayify(\n//     readFileSync(privateKey.slice(1), { encoding: 'utf-8' })\n//   );\n// }\nconst address = ethers.utils.computeAddress(privateKey);\nconst signer = new ethers.utils.SigningKey(privateKey);\nconst app = makeApp(signer, '/');\nconsole.log(`Serving on port ${port} with signing address ${address}`);\napp.listen(port);\n"],"names":["prisma","_globalThis$prismaGlo","globalThis","prismaGlobal","PrismaClient","$extends","withAccelerate","prismaClientSingleton","getAddress","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","node","wrap","_context","prev","next","ens","findUnique","where","select","address","abrupt","sent","stop","_x","apply","arguments","getText","_ref2","_callee2","_context2","text","_x2","getContenthash","_ref3","_callee3","_context3","contenthash","_x3","ZERO_ADDRESS","addr","_addr","name","coinType","_addresses","addresses","_addr2","ttl","t0","_x4","_text","key","texts","_text2","value","_x5","_contenthash","contenthashRes","_contenthash2","Resolver","ethers","utils","Interface","Resolver_abi","decodeDnsName","dnsname","labels","idx","len","readUInt8","push","slice","toString","join","queryHandlers","addr(bytes32)","_addrBytes","_args","_yield$getAddr","getAddr","result","addr(bytes32,uint256)","_addrBytes32Uint","args","_yield$getAddr2","text(bytes32,string)","_textBytes32String","_yield$text","_x6","contenthash(bytes32)","_contenthashBytes","_callee4","_yield$getContentHash","_context4","getContentHash","_x7","_x8","query","_x9","_x10","_query","_callee6","data","_Resolver$parseTransa","signature","handler","_yield$handler","_context6","parseTransaction","nameprep","Error","namehash","undefined","encodeFunctionResult","validUntil","Math","floor","Date","now","makeApp","signer","path","_func","server","Server","add","IResolverService_abi","type","func","_callee5","request","_yield$query","messageHash","sig","sigData","_context5","Buffer","from","solidityKeccak256","to","keccak256","signDigest","hexConcat","r","_vs","_x11","_x12","makeServer","privateKey","computeAddress","app","SigningKey","console","log","listen"],"mappings":"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"}